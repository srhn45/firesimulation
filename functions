import numpy as np
from copy import deepcopy
from math import exp, sqrt
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import torch
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import time
from scipy.sparse import lil_matrix
import os
import math
from concurrent.futures import ProcessPoolExecutor, as_completed
import multiprocessing

def gaussian_mixture_field(size, n_components=None):
    '''
    Generate random topology (height distribution).
    '''
    x, y = np.meshgrid(np.linspace(0, 1, size), np.linspace(0, 1, size))
    field = np.zeros((size, size))

    if not n_components:
        n_components = np.random.poisson(20)

    for _ in range(n_components):
        cx, cy = np.random.uniform(0, 1, 2) # random center
        sx, sy = np.random.uniform(0.01, 0.2, 2) # random covariance scale
        w = np.random.exponential(10) # weight scale

        gaussian = w * np.exp(-(((x - cx) ** 2) / (2 * sx**2) +
                                ((y - cy) ** 2) / (2 * sy**2)))
        field += gaussian

    field = (1 - (field - field.min()) / (field.max() - field.min()))*2
    return field

def make_heatmap_gif(simulator, filename="simulation.gif", cmap="plasma"):
    '''
    Create gif of simulation results.
    '''
    
    times = sorted(simulator.maps.keys())
    frames = [simulator.maps[t] for t in times]

    fig, ax = plt.subplots()

    # --- fire as background ---
    vmin, vmax = np.min(frames), np.max(frames)
    fire_img = ax.imshow(frames[0], cmap=cmap, vmin=vmin, vmax=vmax)

    # --- terrain overlay ---
    terrain_img = ax.imshow(simulator.terrain, cmap="Greens", alpha=0.2)  # low alpha on top

    cbar = fig.colorbar(fire_img, ax=ax)
    cbar.set_label("Fire Intensity", rotation=270, labelpad=15)

    def update(frame):
        fire_img.set_data(frame)    
        return [fire_img, terrain_img]

    ani = animation.FuncAnimation(
        fig, update, frames=frames, interval=60, blit=True
    )

    ani.save(filename, writer="pillow")
    plt.close(fig)

def adjacency_matrix(length, width):
    '''
    Sparse adjacency matrix generator for an n x n undirected graph, where each node is connected to its immediate neighbors and itself.
    '''
    N = length * width
    adj = lil_matrix((N, N), dtype=np.float32)
    directions = [(-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1), (-1,-1), (0,0)] # 8 sided
    for i in range(N):
        x, y = divmod(i, width)
        for dx, dy in directions:
            nx, ny = x+dx, y+dy
            if 0 <= nx < length and 0 <= ny < width:
                j = nx*width + ny
                adj[i,j] = 1
    return adj.tocoo()

def block_diag_batch(adj, batch_size):
    """
    Build block-diagonal adjacency matrix for efficient processing of batches.
    """
    N = adj.size(0)
    indices = adj.indices()
    values = adj.values()

    offsets = torch.arange(batch_size, device=indices.device) * N
    offsets = offsets.view(1, -1, 1)

    expanded = indices.unsqueeze(1).expand(-1, batch_size, -1)
    expanded = expanded + offsets
    expanded = expanded.permute(1, 0, 2).reshape(2, -1)

    expanded_values = values.repeat(batch_size)

    size = (N * batch_size, N * batch_size)
    return torch.sparse_coo_tensor(expanded, expanded_values, size=size, device=adj.device)